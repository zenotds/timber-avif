<?php
/**
 * Timber AVIF Converter - Performance Optimized Edition
 *
 * @version 2.5.1 - Backend optimization release
 * @author Francesco Zeno Selva
 *
 * Installation:
 * 1. `require_once get_template_directory() . '/path/to/avif.php';` in your functions.php
 * 2. Use in Twig: `{{ image|toavif }}` or `{{ image.src|toavif(65) }}`
 */

use Timber\Image;

class AVIFConverter {

    // -- Configuration Constants --
    const DEFAULT_QUALITY = 80;
    const ENABLE_DEBUG_LOGGING = false;
    const MAX_IMAGE_DIMENSION = 4096; // Prevent memory exhaustion
    const MAX_FILE_SIZE_MB = 50; // Max file size to attempt conversion
    const ONLY_IF_SMALLER = true; // Only use AVIF if smaller than original
    const STALE_LOCK_TIMEOUT = 300; // Remove locks older than 5 minutes
    
    // -- Internal Constants --
    private const CACHE_PREFIX = 'timber_avif_';
    private const CACHE_DURATION = MONTH_IN_SECONDS;
    private const CAPABILITY_CACHE_KEY = 'timber_avif_capability';
    private const CAPABILITY_CACHE_DURATION = WEEK_IN_SECONDS;
    
    // Cached conversion method ('gd', 'imagick', 'exec', or 'none')
    private static $conversion_method = null;

    /**
     * Hooks into WordPress
     */
    public static function init() {
        add_filter('timber/twig', [__CLASS__, 'add_twig_filters']);
        add_action('admin_notices', [__CLASS__, 'check_avif_support_admin_notice']);

        // Detect capabilities on init if not cached
        self::detect_capabilities();
    }

    /**
     * Registers the custom 'toavif' filter
     */
    public static function add_twig_filters($twig) {
        $twig->addFilter(new \Twig\TwigFilter('toavif', [__CLASS__, 'convert_to_avif']));
        return $twig;
    }

    /**
     * Main conversion logic with enhanced error prevention
     */
    public static function convert_to_avif($src, $quality = self::DEFAULT_QUALITY, $force = false) {
        // Early return for empty sources
        if (empty($src)) {
            return '';
        }

        // Validate quality parameter
        $quality = max(1, min(100, intval($quality)));

        // Check if conversion is available at all
        if (self::$conversion_method === 'none') {
            return is_string($src) ? $src : (($src instanceof \Timber\Image) ? $src->src : '');
        }

        // Get image details
        $details = self::get_image_details($src);
        $file_path = $details['path'];
        $original_url = $details['url'];

        // Validate file existence
        if (!$file_path || !file_exists($file_path)) {
            self::log("Source file not found: '{$original_url}'", 'warning');
            return $original_url;
        }

        // Check file size before processing
        $file_size_mb = filesize($file_path) / 1024 / 1024;
        if ($file_size_mb > self::MAX_FILE_SIZE_MB) {
            self::log("File too large for conversion ({$file_size_mb}MB): {$original_url}", 'info');
            return $original_url;
        }

        // Validate image dimensions to prevent memory exhaustion
        $image_info = @getimagesize($file_path);
        if (!$image_info) {
            self::log("Unable to read image info: {$file_path}", 'warning');
            return $original_url;
        }

        if ($image_info[0] > self::MAX_IMAGE_DIMENSION || $image_info[1] > self::MAX_IMAGE_DIMENSION) {
            self::log("Image dimensions exceed maximum ({$image_info[0]}x{$image_info[1]}): {$file_path}", 'info');
            return $original_url;
        }

        // Generate AVIF path
        $avif_path = self::get_avif_path($file_path, $quality);
        $avif_url = str_replace(wp_basename($file_path), wp_basename($avif_path), $original_url);

        // Check if AVIF already exists and is valid
        if (!$force && file_exists($avif_path) && filesize($avif_path) > 0) {
            // Verify file is not corrupted (basic check)
            if (self::is_valid_avif($avif_path)) {
                return $avif_url;
            } else {
                // Corrupted file detected, remove it
                @unlink($avif_path);
                self::log("Corrupted AVIF file removed: {$avif_path}", 'warning');
            }
        }

        // Check write permissions
        $target_dir = dirname($avif_path);
        if (!is_writable($target_dir)) {
            self::log("Upload directory is not writable: {$target_dir}", 'error');
            return $original_url;
        }

        // Prevent race conditions with file locking
        $lock_file = $avif_path . '.lock';

        // Clean up stale locks (older than STALE_LOCK_TIMEOUT seconds)
        if (file_exists($lock_file)) {
            $lock_age = time() - filemtime($lock_file);
            if ($lock_age > self::STALE_LOCK_TIMEOUT) {
                @unlink($lock_file);
                self::log("Removed stale lock file (age: {$lock_age}s): {$lock_file}", 'warning');
            }
        }

        $lock_handle = @fopen($lock_file, 'c');

        if (!$lock_handle || !flock($lock_handle, LOCK_EX | LOCK_NB)) {
            // Another process is already converting this image
            self::log("Conversion already in progress: {$avif_path}", 'info');

            // Return original URL immediately (non-blocking)
            // Next request will serve the converted version if ready
            if ($lock_handle) {
                fclose($lock_handle);
            }
            return $original_url;
        }

        try {
            // Perform conversion with cached method
            $success = self::perform_conversion($file_path, $avif_path, $quality);

            if ($success) {
                // Verify the created file is valid
                if (!self::is_valid_avif($avif_path)) {
                    @unlink($avif_path);
                    self::log("Generated AVIF file failed validation: {$avif_path}", 'error');
                    $success = false;
                } else {
                    // Check if AVIF is actually smaller than original
                    if (self::ONLY_IF_SMALLER) {
                        $original_size = filesize($file_path);
                        $avif_size = filesize($avif_path);

                        if ($avif_size >= $original_size) {
                            @unlink($avif_path);
                            $savings = $original_size - $avif_size;
                            self::log("AVIF not smaller than original ({$savings} bytes), removed: {$avif_path}", 'info');
                            $success = false;
                        } else {
                            $percent_saved = round((1 - $avif_size / $original_size) * 100, 1);
                            self::log("AVIF created successfully, {$percent_saved}% smaller: {$avif_path}", 'info');
                        }
                    }
                }
            }

            // Release lock
            flock($lock_handle, LOCK_UN);
            fclose($lock_handle);
            @unlink($lock_file);

            return $success ? $avif_url : $original_url;
            
        } catch (\Exception $e) {
            // Ensure lock is released on exception
            if ($lock_handle) {
                flock($lock_handle, LOCK_UN);
                fclose($lock_handle);
            }
            @unlink($lock_file);

            self::log("Exception during conversion: " . $e->getMessage(), 'error');
            return $original_url;
        }
    }
    
    /**
     * Validates that an AVIF file is not corrupted
     */
    private static function is_valid_avif($path) {
        // Basic validation: file exists and has content
        if (!file_exists($path) || filesize($path) < 100) {
            return false;
        }
        
        // Check AVIF magic bytes (ftyp with avif brand)
        $handle = @fopen($path, 'rb');
        if (!$handle) {
            return false;
        }
        
        $header = fread($handle, 16);
        fclose($handle);
        
        // Look for 'ftyp' and 'avif' markers
        return (strpos($header, 'ftyp') !== false && strpos($header, 'avif') !== false);
    }
    
    /**
     * Detects and caches the best available conversion method
     */
    public static function detect_capabilities() {
        // Return cached result if available
        if (self::$conversion_method !== null) {
            return self::$conversion_method;
        }
        
        // Check transient cache
        $cached = get_transient(self::CAPABILITY_CACHE_KEY);
        if ($cached !== false) {
            self::$conversion_method = $cached;
            return $cached;
        }
        
        // Test methods in order of preference
        $method = 'none';
        
        if (function_exists('imageavif') && self::test_gd_conversion()) {
            $method = 'gd';
        } elseif (extension_loaded('imagick') && self::test_imagick_conversion()) {
            $method = 'imagick';
        } elseif (self::is_exec_available() && self::test_exec_conversion()) {
            $method = 'exec';
        }
        
        // Cache the result
        set_transient(self::CAPABILITY_CACHE_KEY, $method, self::CAPABILITY_CACHE_DURATION);
        self::$conversion_method = $method;

        self::log("Detected conversion method: {$method}", 'info');
        return $method;
    }
    
    /**
     * Tests if GD can convert to AVIF
     */
    private static function test_gd_conversion() {
        try {
            // Create a simple 1x1 image
            $test_image = @imagecreatetruecolor(1, 1);
            if (!$test_image) {
                return false;
            }
            
            // Try to convert to AVIF in memory
            ob_start();
            $result = @imageavif($test_image, null, 80);
            ob_end_clean();
            
            imagedestroy($test_image);
            return $result !== false;
        } catch (\Exception $e) {
            return false;
        }
    }
    
    /**
     * Tests if ImageMagick can convert to AVIF
     */
    private static function test_imagick_conversion() {
        try {
            if (empty(\Imagick::queryFormats('AVIF'))) {
                return false;
            }
            
            // Create a simple test image
            $imagick = new \Imagick();
            $imagick->newImage(1, 1, 'white');
            $imagick->setImageFormat('avif');
            
            // Test if we can get blob
            $blob = $imagick->getImageBlob();
            $imagick->clear();
            
            return !empty($blob);
        } catch (\Exception $e) {
            return false;
        }
    }
    
    /**
     * Tests if exec command can convert to AVIF
     */
    private static function test_exec_conversion() {
        if (!self::is_exec_available()) {
            return false;
        }
        
        // Test if ImageMagick/GraphicsMagick is available
        @exec('magick --version 2>&1', $output, $return_var);
        if ($return_var === 0) {
            return true;
        }
        
        @exec('convert --version 2>&1', $output, $return_var);
        return $return_var === 0;
    }

    /**
     * Resolves image details with optimized SQL query
     */
    private static function get_image_details($src) {
        // Handle Timber\Image objects
        if ($src instanceof \Timber\Image) {
            return ['path' => $src->file_loc, 'url' => $src->src];
        }

        // Handle string URLs
        if (is_string($src)) {
            $url = $src;
            
            // Check theme files
            $theme_dir = get_template_directory();
            $theme_url = get_template_directory_uri();
            
            if (str_starts_with($url, $theme_url)) {
                $path = str_replace($theme_url, $theme_dir, $url);
                return ['path' => $path, 'url' => $url];
            }
            
            // Check uploads directory
            $upload_dir = wp_upload_dir();
            if (str_starts_with($url, $upload_dir['baseurl'])) {
                $path = str_replace($upload_dir['baseurl'], $upload_dir['basedir'], $url);
                return ['path' => $path, 'url' => $url];
            }
            
            // Try Timber factory methods
            try {
                $image = null;
                if (method_exists('\Timber\Timber', 'get_image')) {
                    $image = \Timber\Timber::get_image($url);
                } elseif (method_exists('\Timber\ImageHelper', 'get_image')) {
                    $image = \Timber\ImageHelper::get_image($url);
                } else {
                    $attachment_id = self::get_attachment_id_from_url($url);
                    if ($attachment_id) {
                        $image = \Timber\Timber::get_post($attachment_id);
                    }
                }
                
                if ($image && isset($image->file_loc)) {
                    return ['path' => $image->file_loc, 'url' => $image->src];
                }
            } catch (\Exception $e) {
                self::log("Error creating Timber image: " . $e->getMessage(), 'warning');
            }

            return ['path' => null, 'url' => $url];
        }

        return ['path' => null, 'url' => ''];
    }

    /**
     * Optimized attachment ID lookup with caching
     */
    private static function get_attachment_id_from_url($url) {
        // Try object cache first
        $cache_key = 'avif_att_' . md5($url);
        $cached_id = wp_cache_get($cache_key, 'avif_converter');
        
        if ($cached_id !== false) {
            return $cached_id === 'none' ? null : intval($cached_id);
        }
        
        // Use WordPress function if available
        $attachment_id = attachment_url_to_postid($url);
        
        if (!$attachment_id) {
            // Fallback to optimized query with proper indexing
            global $wpdb;
            
            // Try guid match first (faster with index)
            $attachment_id = $wpdb->get_var($wpdb->prepare(
                "SELECT ID FROM {$wpdb->posts} WHERE guid = %s AND post_type = 'attachment' LIMIT 1",
                $url
            ));
            
            // Try meta lookup for scaled images
            if (!$attachment_id) {
                $filename = basename($url);
                $attachment_id = $wpdb->get_var($wpdb->prepare(
                    "SELECT post_id FROM {$wpdb->postmeta} 
                     WHERE meta_key = '_wp_attached_file' 
                     AND meta_value LIKE %s 
                     LIMIT 1",
                    '%' . $wpdb->esc_like($filename)
                ));
            }
        }
        
        // Cache result
        wp_cache_set(
            $cache_key, 
            $attachment_id ? $attachment_id : 'none', 
            'avif_converter', 
            HOUR_IN_SECONDS
        );
        
        return $attachment_id ? intval($attachment_id) : null;
    }

    /**
     * Performs conversion using the detected best method
     */
    private static function perform_conversion($source, $destination, $quality) {
        // Use cached method directly instead of trying all
        switch (self::$conversion_method) {
            case 'gd':
                return self::convert_with_gd($source, $destination, $quality);
            
            case 'imagick':
                return self::convert_with_imagick($source, $destination, $quality);
            
            case 'exec':
                return self::convert_with_exec($source, $destination, $quality);


            default:
                self::log("No conversion method available for: {$source}", 'error');
                return false;
        }
    }

    /**
     * GD conversion with enhanced error handling
     */
    private static function convert_with_gd($source, $destination, $quality) {
        try {
            $image_type = @exif_imagetype($source);
            if (!$image_type) {
                return false;
            }
            
            // Increase memory limit for large images
            $memory_needed = self::estimate_memory_needed($source, $image_type);
            self::ensure_memory_limit($memory_needed);
            
            $image = match ($image_type) {
                IMAGETYPE_JPEG => @imagecreatefromjpeg($source),
                IMAGETYPE_PNG => @imagecreatefrompng($source),
                IMAGETYPE_WEBP => @imagecreatefromwebp($source),
                IMAGETYPE_GIF => @imagecreatefromgif($source),
                default => null,
            };

            if (!$image) {
                self::log("GD failed to create image resource", 'error');
                return false;
            }

            // Preserve alpha channel for PNG
            if ($image_type === IMAGETYPE_PNG) {
                imagealphablending($image, false);
                imagesavealpha($image, true);
            }

            $success = @imageavif($image, $destination, $quality);
            imagedestroy($image);

            return $success;
        } catch (\Exception $e) {
            self::log("GD Exception: " . $e->getMessage(), 'error');
            return false;
        }
    }

    /**
     * ImageMagick conversion with enhanced error handling
     */
    private static function convert_with_imagick($source, $destination, $quality) {
        try {
            $imagick = new \Imagick($source);
            
            // Set memory and time limits
            $imagick->setResourceLimit(\Imagick::RESOURCETYPE_MEMORY, 256 * 1024 * 1024); // 256MB
            $imagick->setResourceLimit(\Imagick::RESOURCETYPE_TIME, 60); // 60 seconds
            
            $imagick->setImageFormat('avif');
            $imagick->setImageCompressionQuality($quality);
            $imagick->stripImage();
            
            $success = $imagick->writeImage($destination);
            $imagick->clear();
            $imagick->destroy();

            return $success;
        } catch (\Exception $e) {
            self::log("ImageMagick Exception: " . $e->getMessage(), 'error');
            return false;
        }
    }

    /**
     * Exec conversion with fallback commands
     */
    private static function convert_with_exec($source, $destination, $quality) {
        $source_arg = escapeshellarg($source);
        $dest_arg = escapeshellarg($destination);
        $quality_arg = intval($quality);
        
        // Try magick command first (ImageMagick 7+)
        $command = "magick {$source_arg} -quality {$quality_arg} {$dest_arg} 2>&1";
        @exec($command, $output, $return_var);

        if ($return_var === 0 && file_exists($destination) && filesize($destination) > 0) {
            return true;
        }
        
        // Fallback to convert command (ImageMagick 6)
        $command = "convert {$source_arg} -quality {$quality_arg} {$dest_arg} 2>&1";
        @exec($command, $output, $return_var);

        if ($return_var === 0 && file_exists($destination) && filesize($destination) > 0) {
            return true;
        }

        self::log("Exec failed. Output: " . implode(' ', $output), 'error');
        return false;
    }
    
    /**
     * Estimates memory needed for image processing
     */
    private static function estimate_memory_needed($file_path, $image_type) {
        $image_info = @getimagesize($file_path);
        if (!$image_info) {
            return 64 * 1024 * 1024; // Default 64MB
        }
        
        $width = $image_info[0];
        $height = $image_info[1];
        $channels = $image_type === IMAGETYPE_PNG ? 4 : 3; // RGBA or RGB
        
        // Formula: width × height × channels × 1.5 (overhead)
        return ceil($width * $height * $channels * 1.5);
    }
    
    /**
     * Ensures sufficient memory limit
     */
    private static function ensure_memory_limit($needed_bytes) {
        $current_limit = ini_get('memory_limit');
        
        if ($current_limit == -1) {
            return; // Unlimited
        }
        
        $current_bytes = self::parse_memory_limit($current_limit);
        $required_bytes = $needed_bytes + (32 * 1024 * 1024); // Add 32MB buffer
        
        if ($current_bytes < $required_bytes) {
            $new_limit = ceil($required_bytes / 1024 / 1024) . 'M';
            @ini_set('memory_limit', $new_limit);
            self::log("Increased memory limit to {$new_limit}", 'info');
        }
    }
    
    /**
     * Parses memory limit string to bytes
     */
    private static function parse_memory_limit($limit) {
        $limit = trim($limit);
        $last = strtolower($limit[strlen($limit) - 1]);
        $value = (int) $limit;
        
        return match($last) {
            'g' => $value * 1024 * 1024 * 1024,
            'm' => $value * 1024 * 1024,
            'k' => $value * 1024,
            default => $value,
        };
    }
    
    /**
     * Generates AVIF path with quality suffix
     */
    private static function get_avif_path($file_path, $quality) {
        $filename = pathinfo($file_path, PATHINFO_FILENAME);
        $dirname = pathinfo($file_path, PATHINFO_DIRNAME);
        
        $suffix = ($quality == self::DEFAULT_QUALITY) ? '' : "-q{$quality}";
        return "{$dirname}/{$filename}{$suffix}.avif";
    }

    /**
     * Checks if exec is available
     */
    private static function is_exec_available() {
        if (!function_exists('exec')) {
            return false;
        }
        
        $disabled = explode(',', ini_get('disable_functions'));
        return !in_array('exec', array_map('trim', $disabled));
    }

    /**
     * Structured logging with severity levels
     *
     * @param string $message The log message
     * @param string $level Severity level: 'debug', 'info', 'warning', 'error'
     */
    private static function log($message, $level = 'debug') {
        if (!self::ENABLE_DEBUG_LOGGING || !defined('WP_DEBUG') || !WP_DEBUG) {
            return;
        }

        $valid_levels = ['debug', 'info', 'warning', 'error'];
        if (!in_array($level, $valid_levels)) {
            $level = 'debug';
        }

        $level_upper = strtoupper($level);
        error_log("[Timber AVIF][{$level_upper}] {$message}");
    }

    /**
     * Admin notice for missing AVIF support
     */
    public static function check_avif_support_admin_notice() {
        // Only show if we've detected no support
        if (self::detect_capabilities() !== 'none') {
            return;
        }

        // Only show to admins
        if (!current_user_can('manage_options')) {
            return;
        }

        echo '<div class="notice notice-warning is-dismissible">';
        echo '<p><strong>Timber AVIF Converter:</strong> No server support detected for AVIF conversion. ';
        echo 'Images will be served in their original format. ';
        echo 'Please install GD (PHP 8.1+), ImageMagick, or GraphicsMagick with AVIF support.</p>';
        echo '</div>';
    }

    /**
     * Clears all caches
     */
    public static function clear_cache() {
        // Clear transient cache
        delete_transient(self::CAPABILITY_CACHE_KEY);
        
        // Clear object cache
        wp_cache_flush_group('avif_converter');
        
        // Reset static property
        self::$conversion_method = null;
        
        // Re-detect capabilities
        self::detect_capabilities();
        
        return "AVIF cache cleared. Detected method: " . self::$conversion_method;
    }
    
    /**
     * Cleanup corrupted/partial AVIF files
     */
    public static function cleanup_invalid_files($directory = null) {
        if (!$directory) {
            $upload_dir = wp_upload_dir();
            $directory = $upload_dir['basedir'];
        }
        
        $count = 0;
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($directory, \RecursiveDirectoryIterator::SKIP_DOTS)
        );
        
        foreach ($iterator as $file) {
            if ($file->getExtension() === 'avif') {
                if (!self::is_valid_avif($file->getPathname())) {
                    @unlink($file->getPathname());
                    $count++;
                    self::log("Removed corrupted AVIF: " . $file->getPathname(), 'warning');
                }
            }
        }
        
        return "Cleaned up {$count} invalid AVIF files.";
    }
}

// Initialize
AVIFConverter::init();

// WP-CLI commands
if (defined('WP_CLI') && WP_CLI) {
    WP_CLI::add_command('timber-avif clear-cache', ['AVIFConverter', 'clear_cache']);
    WP_CLI::add_command('timber-avif cleanup', ['AVIFConverter', 'cleanup_invalid_files']);
    WP_CLI::add_command('timber-avif detect', function() {
        $method = AVIFConverter::detect_capabilities();
        WP_CLI::success("Detected conversion method: {$method}");
    });

    WP_CLI::add_command('timber-avif bulk', function($args, $assoc_args) {
        $force = isset($assoc_args['force']) && $assoc_args['force'];
        $quality = isset($assoc_args['quality']) ? intval($assoc_args['quality']) : AVIFConverter::DEFAULT_QUALITY;
        $limit = isset($assoc_args['limit']) ? intval($assoc_args['limit']) : -1;

        WP_CLI::log("Starting bulk AVIF conversion (quality: {$quality}, force: " . ($force ? 'yes' : 'no') . ")");

        $query_args = [
            'post_type' => 'attachment',
            'post_mime_type' => ['image/jpeg', 'image/png', 'image/webp', 'image/gif'],
            'posts_per_page' => $limit,
            'post_status' => 'any',
            'fields' => 'ids'
        ];

        $attachments = get_posts($query_args);
        $total = count($attachments);
        $converted = 0;
        $skipped = 0;
        $failed = 0;

        if ($total === 0) {
            WP_CLI::warning('No image attachments found.');
            return;
        }

        $progress = \WP_CLI\Utils\make_progress_bar("Converting {$total} images", $total);

        foreach ($attachments as $attachment_id) {
            $file_path = get_attached_file($attachment_id);

            if (!$file_path || !file_exists($file_path)) {
                $skipped++;
                $progress->tick();
                continue;
            }

            $result = AVIFConverter::convert_to_avif($file_path, $quality, $force);

            // Check if AVIF was created
            $avif_path = str_replace(
                ['.jpg', '.jpeg', '.png', '.webp', '.gif'],
                ['.avif', '.avif', '.avif', '.avif', '.avif'],
                strtolower($file_path)
            );

            if ($result !== $file_path && file_exists($avif_path)) {
                $converted++;
            } else {
                $failed++;
            }

            $progress->tick();
        }

        $progress->finish();

        WP_CLI::success("Bulk conversion complete!");
        WP_CLI::log("Converted: {$converted}");
        WP_CLI::log("Skipped: {$skipped}");
        WP_CLI::log("Failed: {$failed}");
    });
}
